package bot

import (
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/bwmarrin/discordgo"
)

// SlashCommands defines all available slash commands
var SlashCommands = []*discordgo.ApplicationCommand{
	{
		Name:        "reset",
		Description: "Permanently delete all your conversation history and memories",
	},
	{
		Name:        "stats",
		Description: "See what Marin remembers about you",
	},
	{
		Name:        "mood",
		Description: "Check Marin's current mood",
	},
	{
		Name:        "affection",
		Description: "Check your relationship status with Marin",
	},
	{
		Name:        "test-command",
		Description: "A test command generated by Toolsmith",
	},
}

// SlashCommandHandlers maps command names to their handler functions
var SlashCommandHandlers = map[string]func(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate){
	"reset":        handleResetCommand,
	"stats":        handleStatsCommand,
	"mood":         handleMoodCommand,
	"affection":    handleAffectionCommand,
	"test-command": handleTestCommandCommand,
}

// handleResetCommand handles the /reset slash command
func handleResetCommand(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate) {
	// Send confirmation dialog
	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Content: "Are you sure you want to reset your memory? This cannot be undone.",
			Flags:   discordgo.MessageFlagsEphemeral,
			Components: []discordgo.MessageComponent{
				discordgo.ActionsRow{
					Components: []discordgo.MessageComponent{
						discordgo.Button{
							Label:    "Confirm Reset",
							Style:    discordgo.DangerButton,
							CustomID: "reset_confirm",
							Emoji: &discordgo.ComponentEmoji{
								Name: "ðŸ—‘ï¸",
							},
						},
						discordgo.Button{
							Label:    "Cancel",
							Style:    discordgo.SecondaryButton,
							CustomID: "reset_cancel",
							Emoji: &discordgo.ComponentEmoji{
								Name: "âœ–ï¸",
							},
						},
					},
				},
			},
		},
	})

	if err != nil {
		log.Printf("Error responding to reset command: %v", err)
	}
}

// handleResetConfirm handles the confirmation of memory reset
func handleResetConfirm(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate) {
	// Get user ID
	var userID string
	if i.Member != nil {
		userID = i.Member.User.ID
	} else if i.User != nil {
		userID = i.User.ID
	} else {
		log.Printf("Error: Could not determine user ID for reset confirm")
		return
	}

	// Reset the user's memory
	err := h.ResetMemory(userID)

	responseContent := "Memory reset! Starting fresh. ðŸ’­âœ¨"
	if err != nil {
		log.Printf("Error resetting memory for user %s: %v", userID, err)
		responseContent = "Ugh, something went wrong trying to reset your memory... Try again later?"
	}

	// Respond to the interaction (update message to remove buttons)
	err = s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseUpdateMessage,
		Data: &discordgo.InteractionResponseData{
			Content:    responseContent,
			Components: []discordgo.MessageComponent{}, // Remove buttons
		},
	})

	if err != nil {
		log.Printf("Error responding to reset confirm: %v", err)
	}
}

// handleResetCancel handles the cancellation of memory reset
func handleResetCancel(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate) {
	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseUpdateMessage,
		Data: &discordgo.InteractionResponseData{
			Content:    "Reset cancelled! Keeping everything as is. âœ¨",
			Components: []discordgo.MessageComponent{}, // Remove buttons
		},
	})

	if err != nil {
		log.Printf("Error responding to reset cancel: %v", err)
	}
}

// handleStatsCommand handles the /stats slash command - shows what Marin remembers
func handleStatsCommand(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate) {
	// Get user ID
	var userID string
	var userName string
	if i.Member != nil {
		userID = i.Member.User.ID
		userName = i.Member.User.Username
		if i.Member.User.GlobalName != "" {
			userName = i.Member.User.GlobalName
		}
	} else if i.User != nil {
		userID = i.User.ID
		userName = i.User.Username
		if i.User.GlobalName != "" {
			userName = i.User.GlobalName
		}
	} else {
		log.Printf("Error: Could not determine user ID for stats command")
		return
	}

	// Get facts about the user
	facts, err := h.memoryStore.GetFacts(userID)

	if err != nil {
		log.Printf("Error getting facts for user %s: %v", userID, err)
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{
				Content: "Hmm, I had trouble checking my notes... Try again?",
				Flags:   discordgo.MessageFlagsEphemeral,
			},
		})
		return
	}

	var embed *discordgo.MessageEmbed

	if len(facts) == 0 {
		embed = &discordgo.MessageEmbed{
			Title:       fmt.Sprintf("ðŸ“ Memory File: %s", userName),
			Description: "I don't have any specific notes about you yet!",
			Color:       0x00BFFF, // Deep Sky Blue
			Fields: []*discordgo.MessageEmbedField{
				{
					Name: "How to help me remember:",
					Value: "â€¢ Tell me about your **hobbies** (gaming, cosplay?)\n" +
						"â€¢ Mention your **job** or what you study\n" +
						"â€¢ Share your **likes/dislikes**\n\n" +
						"*Just chat naturally, I'll take notes!* ðŸ“",
				},
			},
		}
	} else {
		// Format facts nicely
		factList := "â€¢ " + strings.Join(facts, "\nâ€¢ ")

		// If factList is too long for one field (1024 chars), truncate safely
		if len(factList) > 1024 {
			// Convert to runes to safely slice multi-byte characters (like emojis)
			runes := []rune(factList)
			// Discord limit is 1024 characters, but we need room for "..."
			// However, Discord counts characters, not bytes (mostly).
			// To be safe against byte limits, we'll keep it under 1000 characters.
			if len(runes) > 1021 {
				factList = string(runes[:1021]) + "..."
			}
		}

		embed = &discordgo.MessageEmbed{
			Title:       fmt.Sprintf("ðŸ“ Memory File: %s", userName),
			Description: "Here's everything I've noted down about you so far!",
			Color:       0x00BFFF, // Deep Sky Blue
			Fields: []*discordgo.MessageEmbedField{
				{
					Name:   "Observations",
					Value:  factList,
					Inline: false,
				},
			},
			Footer: &discordgo.MessageEmbedFooter{
				Text: "To start fresh, use /reset",
			},
		}
	}

	// Respond to the interaction
	err = s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Embeds: []*discordgo.MessageEmbed{embed},
			Flags:  discordgo.MessageFlagsEphemeral,
		},
	})

	if err != nil {
		log.Printf("Error responding to stats command: %v", err)
	}
}

// buildMoodEmbed creates the embed for the mood display
func buildMoodEmbed(h *Handler) *discordgo.MessageEmbed {
	mood, emoji, description := h.GetCurrentMood()

	// Get color for current mood
	color := MoodColors[mood]
	if color == 0 {
		color = 0xFFD700 // Default to Gold (Happy)
	}

	// Add a little extra flavor based on mood
	var flavorText string
	switch mood {
	case MoodHyper:
		flavorText = "*bounces around excitedly*"
	case MoodSleepy:
		flavorText = "*yawns*"

		flavorText += "\n\n" + getSleepTimeRemaining()
	case MoodFlirty:
		flavorText = "ðŸ˜"
	case MoodNostalgic:
		flavorText = "*stares out the window wistfully*"
	case MoodFocused:
		flavorText = "*adjusts glasses*"
	case MoodBored:
		flavorText = "*sighs*"
	}

	// Construct Embed
	embed := &discordgo.MessageEmbed{
		Title:       fmt.Sprintf("%s Current Mood: %s", emoji, mood),
		Description: description,
		Color:       color,
		Footer: &discordgo.MessageEmbedFooter{
			Text: fmt.Sprintf("Last updated: %s", time.Now().Format("15:04")),
		},
	}

	if flavorText != "" {
		embed.Description += "\n\n" + flavorText
	}

	return embed
}

// handleMoodCommand handles the /mood slash command
func handleMoodCommand(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate) {
	embed := buildMoodEmbed(h)

	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Embeds: []*discordgo.MessageEmbed{embed},
			Flags:  discordgo.MessageFlagsEphemeral,
			Components: []discordgo.MessageComponent{
				discordgo.ActionsRow{
					Components: []discordgo.MessageComponent{
						discordgo.Button{
							Label:    "Refresh",
							Style:    discordgo.SecondaryButton,
							CustomID: "mood_refresh",
							Emoji: &discordgo.ComponentEmoji{
								Name: "ðŸ”„",
							},
						},
					},
				},
			},
		},
	})

	if err != nil {
		log.Printf("Error responding to mood command: %v", err)
	}
}

// handleMoodRefresh updates the existing mood message
func handleMoodRefresh(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate) {
	embed := buildMoodEmbed(h)

	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseUpdateMessage,
		Data: &discordgo.InteractionResponseData{
			Embeds: []*discordgo.MessageEmbed{embed},
			Components: []discordgo.MessageComponent{
				discordgo.ActionsRow{
					Components: []discordgo.MessageComponent{
						discordgo.Button{
							Label:    "Refresh",
							Style:    discordgo.SecondaryButton,
							CustomID: "mood_refresh",
							Emoji: &discordgo.ComponentEmoji{
								Name: "ðŸ”„",
							},
						},
					},
				},
			},
		},
	})

	if err != nil {
		log.Printf("Error responding to mood refresh: %v", err)
	}
}

// buildAffectionEmbed creates the embed for the affection display
func buildAffectionEmbed(h *Handler, userID, userName string) *discordgo.MessageEmbed {
	affection, level := h.GetUserAffection(userID)
	streak, _ := h.memoryStore.GetStreak(userID)

	// Build flavor text
	var flavorText string
	switch level.Name {
	case "Stranger":
		flavorText = "we just met~ let's chat more!"
	case "Familiar Face":
		flavorText = "i think i've seen you around? hey there!"
	case "Acquaintance":
		flavorText = "i'm starting to remember you~"
	case "Casual Friend":
		flavorText = "always nice to chat with you~"
	case "Friend":
		flavorText = "we're friends now! nice"
	case "Good Friend":
		flavorText = "you're pretty cool, you know that?"
	case "Close Friend":
		flavorText = "you're like... really important to me"
	case "Best Friend":
		flavorText = "i literally think about you all the time"
	case "Soulmate":
		flavorText = "you complete me. seriously. ðŸ’•"
	case "Special Someone":
		flavorText = "...you know how i feel about you right? ðŸ’•"
	default:
		flavorText = "hello! nice to see you~"
	}

	// Create Embed
	return &discordgo.MessageEmbed{
		Title:       fmt.Sprintf("ðŸ’• Relationship with %s", userName),
		Description: flavorText,
		Color:       0xFF69B4, // Hot Pink
		Fields: []*discordgo.MessageEmbedField{
			{
				Name:   "Current Status",
				Value:  FormatAffectionDisplay(affection, streak),
				Inline: false,
			},
		},
		Footer: &discordgo.MessageEmbedFooter{
			Text: fmt.Sprintf("Last updated: %s", time.Now().Format("15:04")),
		},
	}
}

// handleAffectionCommand handles the /affection slash command
func handleAffectionCommand(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate) {
	// Get user ID
	var userID string
	var userName string
	if i.Member != nil {
		userID = i.Member.User.ID
		userName = i.Member.User.Username
		if i.Member.User.GlobalName != "" {
			userName = i.Member.User.GlobalName
		}
	} else if i.User != nil {
		userID = i.User.ID
		userName = i.User.Username
		if i.User.GlobalName != "" {
			userName = i.User.GlobalName
		}
	} else {
		log.Printf("Error: Could not determine user ID for affection command")
		return
	}

	embed := buildAffectionEmbed(h, userID, userName)

	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Embeds: []*discordgo.MessageEmbed{embed},
			Flags:  discordgo.MessageFlagsEphemeral,
			Components: []discordgo.MessageComponent{
				discordgo.ActionsRow{
					Components: []discordgo.MessageComponent{
						discordgo.Button{
							Label:    "Refresh",
							Style:    discordgo.SecondaryButton,
							CustomID: "affection_refresh",
							Emoji: &discordgo.ComponentEmoji{
								Name: "ðŸ”„",
							},
						},
					},
				},
			},
		},
	})

	if err != nil {
		log.Printf("Error responding to affection command: %v", err)
	}
}

// handleAffectionRefresh updates the existing affection message
func handleAffectionRefresh(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate) {
	// Get user ID (refresh button interaction also has user info)
	var userID string
	var userName string
	if i.Member != nil {
		userID = i.Member.User.ID
		userName = i.Member.User.Username
		if i.Member.User.GlobalName != "" {
			userName = i.Member.User.GlobalName
		}
	} else if i.User != nil {
		userID = i.User.ID
		userName = i.User.Username
		if i.User.GlobalName != "" {
			userName = i.User.GlobalName
		}
	} else {
		log.Printf("Error: Could not determine user ID for affection refresh")
		return
	}

	embed := buildAffectionEmbed(h, userID, userName)

	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseUpdateMessage,
		Data: &discordgo.InteractionResponseData{
			Embeds: []*discordgo.MessageEmbed{embed},
			Components: []discordgo.MessageComponent{
				discordgo.ActionsRow{
					Components: []discordgo.MessageComponent{
						discordgo.Button{
							Label:    "Refresh",
							Style:    discordgo.SecondaryButton,
							CustomID: "affection_refresh",
							Emoji: &discordgo.ComponentEmoji{
								Name: "ðŸ”„",
							},
						},
					},
				},
			},
		},
	})

	if err != nil {
		log.Printf("Error responding to affection refresh: %v", err)
	}
}

// InteractionCreate handles all slash command interactions
func (h *Handler) InteractionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
	// Handle slash commands
	if i.Type == discordgo.InteractionApplicationCommand {
		commandName := i.ApplicationCommandData().Name
		if handler, ok := SlashCommandHandlers[commandName]; ok {
			handler(h, s, i)
		} else {
			log.Printf("Unknown slash command: %s", commandName)
		}
		return
	}

	// Handle component interactions (buttons)
	if i.Type == discordgo.InteractionMessageComponent {
		switch i.MessageComponentData().CustomID {
		case "reset_confirm":
			handleResetConfirm(h, s, i)
		case "reset_cancel":
			handleResetCancel(h, s, i)
		case "mood_refresh":
			handleMoodRefresh(h, s, i)
		case "affection_refresh":
			handleAffectionRefresh(h, s, i)
		}
		return
	}
}

// RegisterSlashCommands registers all slash commands with Discord
func RegisterSlashCommands(s *discordgo.Session, guildID string) ([]*discordgo.ApplicationCommand, error) {
	log.Println("Registering slash commands...")

	registeredCommands := make([]*discordgo.ApplicationCommand, len(SlashCommands))

	for i, cmd := range SlashCommands {
		// Register globally (guildID = "") or for a specific guild
		registeredCmd, err := s.ApplicationCommandCreate(s.State.User.ID, guildID, cmd)
		if err != nil {
			log.Printf("Cannot create '%s' command: %v", cmd.Name, err)
			return nil, err
		}
		registeredCommands[i] = registeredCmd
		log.Printf("Registered command: %s", cmd.Name)
	}

	return registeredCommands, nil
}

// UnregisterSlashCommands removes all registered slash commands
func UnregisterSlashCommands(s *discordgo.Session, guildID string, commands []*discordgo.ApplicationCommand) error {
	log.Println("Unregistering slash commands...")

	for _, cmd := range commands {
		err := s.ApplicationCommandDelete(s.State.User.ID, guildID, cmd.ID)
		if err != nil {
			log.Printf("Cannot delete '%s' command: %v", cmd.Name, err)
			return err
		}
		log.Printf("Unregistered command: %s", cmd.Name)
	}

	return nil
}

// getSleepTimeRemaining calculates how long until Marin wakes up (3am Tokyo time)
func getSleepTimeRemaining() string {
	// Tokyo timezone
	loc := time.FixedZone("Asia/Tokyo", 9*60*60)
	now := time.Now().In(loc)
	hour := now.Hour()

	// SLEEPY is from 12am (0) to 3am
	// Calculate time until 3am
	var wakeUpTime time.Time
	if hour >= 0 && hour < 3 {
		// Same day, wake up at 3am
		wakeUpTime = time.Date(now.Year(), now.Month(), now.Day(), 3, 0, 0, 0, loc)
	} else {
		// Already past 3am, shouldn't be sleepy but handle edge case
		return "zzz..."
	}

	remaining := wakeUpTime.Sub(now)
	hours := int(remaining.Hours())
	minutes := int(remaining.Minutes()) % 60

	if hours > 0 {
		return fmt.Sprintf("ðŸ’¤ *wakes up in ~%dh %dm*", hours, minutes)
	}
	return fmt.Sprintf("ðŸ’¤ *wakes up in ~%dm*", minutes)
}

// handleTestCommandCommand handles the /test-command slash command
func handleTestCommandCommand(h *Handler, s *discordgo.Session, i *discordgo.InteractionCreate) {
	// TODO: Implement logic for /test-command
	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Content: "Command /test-command executed! ðŸš€",
			Flags:   discordgo.MessageFlagsEphemeral,
		},
	})

	if err != nil {
		log.Printf("Error responding to test-command command: %v", err)
	}
}
